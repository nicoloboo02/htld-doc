# Plan de pruebas

### Pruebas de backend

El sistema de testing empleado en el código proporcionado se basa en pruebas automatizadas utilizando `pytest` y `pytest_asyncio` para garantizar la calidad y el correcto funcionamiento del software. Este análisis ampliado proporciona una visión más profunda de las características del sistema de testing, sus ventajas y desventajas, así como las pruebas específicas realizadas.

Se han realizado pruebas de integración para cada uno de los diferentes endpoints de la API desarrollada con FastApi utilizando MongoDb como sistema de base de datos. Estas pruebas han sido diseñadas para ir realizandose a la par de las diferentes features a implementar, lo que ha permitido asegurar el correcto funcionamiento de los endpoints previamente al mergeo de los mismos. 

Concretamente se han establecido un conjunto de "reglas" o estándares para la realización similar de todos los test de la aplicación, por ejemplo, se han generado test usando un sistema de llamadas a funciones con nombres facilmente entendible para facilitar el entendimiento de los mismos.
```
@pytest_asyncio.fixture
async def insert_interventions_mongo(mongo_db: Database):
    result = []
    patient = {
        "_id": uuid4(),
        "name": "Pepe",
        "first_surname": "Cast",
        "second_surname": "Cast2",
        "nid": "07344702C",
        "birth_date": "2003-03-08",
        "gender": "Man",
        "address": "Calle 1",
        "contact_phone": "666666666",
        "dossier_number": "1",
        "first_technician": "John Doe",
        "observation": "Observations"
    }

    patient["alias"] = generate_alias(
        patient["name"],
        patient["first_surname"],
        patient["second_surname"])
    patient["registration_date"] = datetime.date.today().isoformat()

    mongo_db['Patient'].insert_one(patient)
    patient["id"] = patient.pop("_id")

    interventions = [
        {
            "_id": uuid4(),
            "date": "2025-03-08",
            "reason": "Food intervention",
            "typology": "Food",
            "observations": "Food intervention",
            "technician": "John Doe",
            "patient": patient,
        },
        {
            "_id": uuid4(),
            "date": "2025-03-08",
            "reason": "Food intervention2",
            "typology": "Food2",
            "observations": "Food intervention2",
            "technician": "John Doe",
            "patient": patient,
        },
    ]

    for intervention in interventions:
        mongo_db['Intervention'].insert_one(intervention)
        result.append(intervention)
    yield result
``` 
En este ejemplo podemos ver el método que utilizaremos durante el test para insertar los diferentes objetos en la base de datos. Posteriormente se definen los test para cada uno de los endpoints y se pasa como parámetros el método mostrado previamente.
```
def test_get_intervention_detail(
        app_client: TestClient,
        insert_interventions_mongo):
    intervention_id = str(insert_interventions_mongo[0]["_id"])
    url = f'{URL_INTERVENTION}/{intervention_id}'
    response = app_client.get(url=url)
    assert response.status_code == 200
    result = response.json()
    assert result["id"] == intervention_id
    assert result["reason"] == "Food intervention"
    assert result["typology"] == "Food"
    assert result["observations"] == "Food intervention"
    assert result["technician"] == "John Doe"
    assert result["patient"]["id"] == str(
        insert_interventions_mongo[0]["patient"]["id"])
    assert result["patient"]["name"] == "Pepe"
    assert result["patient"]["first_surname"] == "Cast"
    assert result["patient"]["second_surname"] == "Cast2"
    assert result["patient"]["alias"] == "pecaca"
    assert result["patient"]["nid"] == "07344702C"
    assert result["patient"]["birth_date"] == "2003-03-08"


def test_create_intervention(app_client: TestClient, insert_patient_mongo):
    patient_id = str(insert_patient_mongo["_id"])
    intervention_data = {
        "date": "2023-03-03T00:00:00",
        "reason": "Food intervention",
        "typology": "Food",
        "observations": "Food intervention",
        "patient_id": patient_id,
        "technician": "John Doe"
    }
    response = app_client.post(url=URL_INTERVENTION, json=intervention_data)
    assert response.status_code == 201
    response_data = response.json()
    assert response_data["date"] == intervention_data["date"]
    assert response_data["reason"] == intervention_data["reason"]
    assert response_data["typology"] == intervention_data["typology"]
    assert response_data["observations"] == intervention_data["observations"]
    assert response_data["technician"] == intervention_data["technician"]


def test_update_intervention(
        app_client: TestClient,
        insert_interventions_mongo: list):
    # Select an intervention to update
    intervention = insert_interventions_mongo[0]
    intervention_id = str(intervention["_id"])
    url = f"{URL_INTERVENTION}/{intervention_id}"

    # Data to update
    updated_data = {
        "date": "2025-03-08T00:00:00",
        "reason": "Updated reason",
        "typology": "Updated typology",
        "observations": "Updated observations",
        "technician": "Jane Doe",
        "update_fields_to_none": ["reason"]
    }

    # Execute the update operation
    response = app_client.patch(url=url, json=updated_data)
    assert response.status_code == 200
    result = response.json()

    # Verify the updated fields
    assert result["date"] == updated_data["date"]
    assert result["typology"] == updated_data["typology"]
    assert result["observations"] == updated_data["observations"]
    assert result["technician"] == updated_data["technician"]


def test_delete_intervention(
        app_client: TestClient,
        insert_interventions_mongo,
        mongo_db: Database):
    intervention = insert_interventions_mongo[0]
    intervention_id = str(intervention["_id"])
    url = f"{URL_INTERVENTION}/{intervention_id}"

    response = app_client.delete(url=url)
    assert response.status_code == 204

    deleted_intervention = mongo_db["Intervention"].find_one(
        {"_id": intervention["_id"]})
    assert deleted_intervention is None
```
El código mostrado es un ejemplo concreto que nos permite comprender la estructura de la totalidad de las pruebas llevadas a cabo durante el desarrollo del proceso.

El uso de pytest ofrece una forma eficaz de automatizar el proceso de prueba, lo que ahorra tiempo y esfuerzo en comparación con las pruebas manuales. Esta automatización se integra sin problemas con FastAPI, simplificando la validación del comportamiento de la API mediante la simulación de solicitudes HTTP. Además, la facilidad de configuración con fixtures facilita la creación y limpieza de datos de prueba. Las pruebas de integración cubren escenarios de uso del mundo real, detectando problemas de interacción entre componentes, como problemas de red o autenticación. Sin embargo, estas pruebas también presentan desafíos, como la dependencia de MongoDB y la complejidad en la configuración de pruebas que involucran archivos externos, lo que puede resultar en un tiempo de ejecución más largo en comparación con las pruebas unitarias. A pesar de esto, el sistema de testing proporciona un entorno controlado con fixtures para la inserción de datos, asegurando una cobertura exhaustiva del comportamiento del sistema, incluyendo la validación de respuestas HTTP. En comparación con otras pruebas, como las unitarias que se centran en funciones individuales, las pruebas de integración ofrecen una visión más amplia del sistema, aunque las pruebas de UI y de rendimiento también son cruciales para garantizar una experiencia de usuario óptima y evaluar el comportamiento bajo carga. En conclusión, el sistema de testing desempeña un papel vital en la calidad del software, adaptándose continuamente a medida que el software evoluciona para abordar nuevos desafíos y características emergentes.

### Pruebas de frontend

El plan de pruebas para el desarrollo frontend se basa en Jest, una biblioteca de pruebas de JavaScript. Este plan tiene varias características, beneficios y limitaciones. Se utiliza Jest para las pruebas unitarias, lo que permite escribir y ejecutar pruebas de manera eficiente. Además, se emplea "mocking" para simular funciones externas, como las llamadas a API, lo que facilita el enfoque en la lógica interna del componente que se está probando. Para renderizar componentes React durante las pruebas, se utiliza la función render de @testing-library/react. También se aplica EsLint para mantener la calidad del código y detectar posibles problemas.

Las pruebas unitarias ayudan a encontrar y solucionar errores de forma temprana, lo que resulta en un código más sólido y mantenible. El "mocking" permite aislar componentes y resolver problemas específicos sin interferencias de otras dependencias. Jest proporciona retroalimentación rápida sobre el estado de las pruebas, lo que facilita la iteración y validación de cambios. Además, la integración con otras herramientas de desarrollo simplifica la inclusión de pruebas en el flujo de trabajo.

Sin embargo, hay algunas limitaciones. El "mocking" puede ser complejo en algunos casos, lo que puede llevar a pruebas poco realistas o incompletas. Las pruebas unitarias se enfocan en partes individuales del código, lo que limita la cobertura en comparación con pruebas de integración o end-to-end. En ciertos contextos, las pruebas unitarias pueden no detectar todos los problemas de integración o comportamiento en un entorno real.

En conclusión, el plan de pruebas con Jest es efectivo para validar el comportamiento de los componentes React. Aunque las pruebas unitarias son útiles para identificar y corregir errores tempranamente, es importante complementarlas con otros tipos de pruebas para asegurar una cobertura completa del sistema.

```
/* eslint-disable no-unused-vars */
import React from 'react'
/* eslint-enable no-unused-vars */
import { render, waitFor, screen } from '@testing-library/react'
import { test, expect, describe, jest } from '@jest/globals'
import InterventionPage from '../../app/interventions/page'
import { fetchDataInterventions } from '../../app/interventions/fetchIntervention.js'

jest.mock('../../app/interventions/fetchIntervention.js')
jest.mock('next/navigation', () => ({
	useRouter: () => ({
		push: jest.fn()
	}),
	useSearchParams: () => ({
		get: jest.fn()
	}),
	usePathname: () => ({
		get: jest.fn()
	})
}))

describe('InterventionList', () => {
	test('Renderizar', async () => {
		const datos = [
			{
				id: 1,
				intervention_date: '2018-05-08T16:29:31.591Z',
				patient: 'John Doe'
			},
			{
				id: 2,
				intervention_date: '2018-05-08T16:29:31.591Z',
				patient: 'Jane Doe'
			}
		]

		fetchDataInterventions.mockResolvedValue(datos)

		const data = await fetchDataInterventions()

		expect(data).toEqual(datos)

		waitFor(async () => {
			render(<InterventionPage />)
			expect(screen.getByText('John Doe')).toBeInTheDocument()
			expect(screen.getByText('Jane Doe')).toBeInTheDocument()
		})
	})
})
```


